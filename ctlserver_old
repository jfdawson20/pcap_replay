/*
SPDX-License-Identifier: MIT
Copyright (c) 2025 jfdawson20

Filename: control_server.c
Description: Primary entry point and support functionality for a light weight socket based control server 
for managing the Pcap Replay dataplane. The control server is launched as a standard pthread (not a dpdk thread)
and bound to the management core so it won't impact datapath performance. 

The control server monitors for requests sent via TCP on a port specified at thread launch time as one of the thread 
arguments. The server operates with json formatted strings as both the command and response payload format. 

A majority of the support functions are statically defined, only used by the main server thread. 

All functions / commmands have a similar flow, a json command is received over the socket in the format {"cmd": "cmdstr"}. basic sanity 
checks are performed (not extensive, this isn't prod code). Commands are dispatched to a handler that selects a specific "return_x" function 
which performs the required command and also formats the return json response. Since responses are just json strings, the specific format differs
depending on the specific command / function. 

*/

#include <arpa/inet.h>
#include <sys/socket.h>
#include <pthread.h>
#include <unistd.h>
#include <jansson.h>
#include <stdio.h>
#include <string.h>
#include <rte_common.h>
#include <rte_ethdev.h>
#include <stdio.h> 
#include <unistd.h>

#include "ppr_app_defines.h"
#include "ppr_control.h"
#include "ppr_stats.h"
#include "ppr_pcap_loader.h"
#include "ppr_flowtable.h"


/* Return json formated global state information. This was the first return function I wrote and was for initial testing purposes. Will extend this
   to include more port state in the future */
static int return_virt_channels(json_t *root, struct pthread_args *thread_args, json_t *cmd_args){
    int portno              = (int)json_integer_value(json_object_get(cmd_args, "portno"));
    int num_virt_channels   = (int)json_integer_value(json_object_get(cmd_args, "virt_channels"));

    printf("configuring port %d for %d virtual channels\n",portno,num_virt_channels);

    thread_args->global_state->virt_channels_per_port[portno] = num_virt_channels;
    
    json_object_set_new(root,"status",json_integer(0)); 
    return 0; 
}



/* enable transmission on a specified port. if the port argument is "-1" transmission is enabled on all configured ports. 
else the port number provided is checked to see if all required port+tx core slots have already been assigned a valid pcap id. 
if not it will return failure, else it will set the relivant port enable flags. 

buffer threads look for this flag to start consuming and populating tx double buffer arrays. 
*/
static int return_port_enable(json_t *root, struct pthread_args *thread_args, json_t *cmd_args, int onoff){
    //extract port number from command
    int portno   = (int)json_integer_value(json_object_get(cmd_args, "portno"));

    //enable all ports
    if(portno == -1){
        for (int i=0; i<thread_args->global_state->ports_configured;i++){

            //check if port slot has a pcap id assigned 
            for (int j=0; j< thread_args->global_state->num_tx_cores;j++){
                if (thread_args->global_state->pcap_storage_t->slot_assignments[i][j] == -1){
                    
                    printf("error, port number %d , txcore %d does not have a pcap slot assigned\n",i,j);
                    json_object_set_new(root,"status",json_integer(-1)); 
                    return -1;

                }
            }
            
            //enable port
            thread_args->global_state->port_enable[i] = onoff;
        }
    } 
    //enable a specific port
    else if (portno >=0 && portno < thread_args->global_state->ports_configured){
        //check if port slot has a pcap id assigned 
        for (int j=0; j< thread_args->global_state->num_tx_cores;j++){
            if (thread_args->global_state->pcap_storage_t->slot_assignments[portno][j] == -1){
                printf("error, port number %d , tx core %d slot does not have a pcap slot assigned\n",portno,j);
                json_object_set_new(root,"status",json_integer(-1)); 
                return -1; 
            }
        }
            
        //enable port
        printf("portno: %d, onoff: %d\n", portno,onoff);
        thread_args->global_state->port_enable[portno] = onoff;     
    }
    else{
        printf("invalid port number provided %d\n", portno);
        json_object_set_new(root,"status",json_integer(-1)); 
        return -1;
    }
 
    json_object_set_new(root,"status",json_integer(0)); 
    return 0; 
}







/* Return json formated global state information. This was the first return function I wrote and was for initial testing purposes. Will extend this
   to include more port state in the future */
static int return_state(json_t *root, struct pthread_args *thread_args){
    
    /* Collect fields for shared state struct */
    //get access to state lock 
    pthread_mutex_lock(&(thread_args->global_state->lock));

    json_object_set_new(root, "app_initialized", json_boolean(thread_args->global_state->app_initialized));
    json_object_set_new(root, "num_ports_configured", json_integer(thread_args->global_state->ports_configured));

    json_t *arr = json_array();

    for (int i=0;i<thread_args->global_state->ports_configured;i++){
        json_array_append_new(arr,json_integer(thread_args->global_state->port_status[i]));
    }
    json_object_set_new(root, "port_status", arr);

    //release lock when done 
    pthread_mutex_unlock(&(thread_args->global_state->lock));

    return 0; 
}

/* Command Handler Function - processes received json formatted commands 
   processes commands, and returns responses */
static void handle_command(const char *msg, int fd, struct pthread_args *thread_args) {
    
    /* Parse the command and confirm is a valid json command if not return error*/
    json_error_t error;
    json_t *root = json_loads(msg, 0, &error);
    if (!root) {
        json_t *err = json_pack("{s:s}", "error", "invalid JSON");
        char *reply = json_dumps(err, 0);
        send(fd, reply, strlen(reply), 0);
        free(reply);
        json_decref(err);
        return;
    }

    /* Extract command as string, keep args as json for flexible parsing per command*/
    const char *cmd   = json_string_value(json_object_get(root, "cmd"));
    json_t *sock_args = json_object_get(root, "args");
    
    json_t *reply = json_object();
    
    /* main logic for selecting how to process a command, this is where we add new hooks for future commands */

    /* If command string is not present, return error message */
    if (!cmd) {
        reply = json_pack("{s:s}", "error", "missing cmd");

    /* Ping Command */
    } else if (strcmp(cmd, "ping") == 0) {
        reply = json_pack("{s:s}", "status", "pong");

    /* fetch all port stats */    
    } else if (strcmp(cmd, "port_stats") == 0) {
        return_port_stats(reply, thread_args);

    } else if (strcmp(cmd, "mem_stats") == 0) {
        return_mem_stats(reply, thread_args);
    
    /* fetch system status information */
    } else if (strcmp(cmd, "status") == 0) {
        return_state(reply, thread_args);

    /* Enable transmission on a port */
    } else if (strcmp(cmd, "tx_enable") == 0) {
        return_port_enable(reply, thread_args, sock_args,1);

    /* Disable transmission on a port */
    } else if (strcmp(cmd, "tx_disable") == 0) {
        return_port_enable(reply, thread_args, sock_args,0);


    /* process pcap load instruction */
    }else if (strcmp(cmd, "load_pcap") == 0){
        return_pcap_loader(reply, thread_args, sock_args);

    }else if (strcmp(cmd, "slot_assign") == 0){
        return_slot_assign(reply, thread_args, sock_args);

    }else if (strcmp(cmd, "virt_channels_enabled") == 0){
        return_virt_channels(reply, thread_args, sock_args);

    /* list pcaps loaded into memory */
    }else if (strcmp(cmd, "list_pcaps") == 0){
        return_pcap_list(reply, thread_args, sock_args);

    /* get tx to buffer core mapping*/
    }else if (strcmp(cmd, "list_coremap") == 0){
        return_list_coremap(reply, thread_args, sock_args);

    /* Unknown Command, return error message*/
    } else {
        reply = json_pack("{s:s}", "error", "unknown command");
    }

    /* Format and Send response */
    char *reply_str = json_dumps(reply, 0);
    //printf("reply string: %s\n", reply_str);
    send(fd, reply_str, strlen(reply_str), 0);
    free(reply_str);
    json_decref(reply);
    json_decref(root);
}

/* Main control server function, listens to socket and handles commands from clients */
void *run_control_server(void *arg) {
    //reclass arg structs passed from the main thread
    struct pthread_args *thread_args = (struct pthread_args *)arg; 
    unsigned int ctl_port = *(unsigned int*)thread_args->private_args;

    /* Create an IPv4 stream oriented (TCP) socket handle */
    int srv_fd = socket(AF_INET, SOCK_STREAM, 0);
    
    /* Configure default socket options */
    int opt = 1;
    setsockopt(srv_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    /* Build socket address properties, bind to CTRL_PORT and listen to local interface only 
       Assumption is DPDK server only communicates with locally running Pcap Replay python service */
    struct sockaddr_in addr = {
        .sin_family = AF_INET,
        .sin_port = htons(ctl_port),
        .sin_addr.s_addr = htonl(INADDR_LOOPBACK)
    };

    /* Bind server to address struct */    
    if (bind(srv_fd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        perror("bind");
        pthread_exit((void *)-1);
    }

    /* Start listening, backlog = 4 = max 4 outstanding TCP connections */
    listen(srv_fd, 4);
    printf("\n[CTRL] Listening on port %d\n", ctl_port);

    /* Main processing loop - accept connection and use handle_command function to process*/
    char buf[MAX_SOCK_PAYLOAD];
    char command[MAX_SOCK_PAYLOAD];
    int command_len = 0; 
    
    while (1) {
        int good_command = 1; 
        int cli_fd = accept(srv_fd, NULL, NULL);
        
        /* If connection invalid don't process anything*/
        if (cli_fd < 0) sched_yield();
        
        /* process received data */
        //printf("[CTRL] Client connected\n");
        while (good_command == 1) {
            /* Read data from client */
            ssize_t n = recv(cli_fd, buf, sizeof(buf), 0);
            // if connection fails, break 
            if (n <= 0) break;

            /* iterate through received data */
            for (int i=0; i < n ; i++) { 
                // grab next byte
                char c = buf[i];
                // if we've hit the terminator character
                if (c == '\n') {
                    //terminate command line 
                    command[command_len] = '\0';
                    
                    //if line contains valid data, process
                    if (command_len > 0) {
                        handle_command(command,cli_fd,thread_args);
                    }

                    command_len = 0; 

                /* else, keep processing received data */
                } else {
                    // if we have room in buffer, keep adding data 
                    if(command_len < sizeof(command) -1){
                        command[command_len++] = c;
                    
                    //overflow case, return malformed command error
                    } else {
                        //printf("bad command\n");
                        json_t *err = json_pack("{s:s}", "error", "Malformed Command");
                        char *reply = json_dumps(err, 0);
                        send(cli_fd, reply, strlen(reply), 0);
                        free(reply);
                        json_decref(err);
                        command_len = 0; 
                        good_command = 0; 
                        break;
                    }
                }
            }
            
            //reset buffers 
            memset(buf,0,sizeof(buf));
            memset(command,0,sizeof(command));

        }
        close(cli_fd);
        //printf("[CTRL] Client disconnected\n");
    }
    close(srv_fd);
}
